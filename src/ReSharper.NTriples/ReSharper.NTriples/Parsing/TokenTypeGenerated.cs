//------------------------------------------------------------------------------
// <auto-generated>
//     Generated by TokenGenerator
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using JetBrains.ReSharper.Psi;
using JetBrains.ReSharper.Psi.ExtensionsAPI.Tree;
using JetBrains.Text;
using JetBrains.ReSharper.Psi.Parsing;

namespace ReSharper.NTriples.Parsing
{
    public static partial class NTriplesTokenType
    {
        #region URI_BEGIN
        private class UriBeginNodeType : FixedTokenNodeType
        {
            public UriBeginNodeType(): base ("URI_BEGIN", "<") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new UriBeginTokenElement(this);
            }
        }
        private class UriBeginTokenElement : FixedTokenElement
        {
            public UriBeginTokenElement(UriBeginNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType URI_BEGIN = new UriBeginNodeType();
        #endregion

        #region URI_END
        private class UriEndNodeType : FixedTokenNodeType
        {
            public UriEndNodeType(): base ("URI_END", ">") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new UriEndTokenElement(this);
            }
        }
        private class UriEndTokenElement : FixedTokenElement
        {
            public UriEndTokenElement(UriEndNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType URI_END = new UriEndNodeType();
        #endregion

        #region DOT
        private class DotNodeType : FixedTokenNodeType
        {
            public DotNodeType(): base ("DOT", ".") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new DotTokenElement(this);
            }
        }
        private class DotTokenElement : FixedTokenElement
        {
            public DotTokenElement(DotNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType DOT = new DotNodeType();
        #endregion

        #region SEMICOLON
        private class SemicolonNodeType : FixedTokenNodeType
        {
            public SemicolonNodeType(): base ("SEMICOLON", ";") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new SemicolonTokenElement(this);
            }
        }
        private class SemicolonTokenElement : FixedTokenElement
        {
            public SemicolonTokenElement(SemicolonNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType SEMICOLON = new SemicolonNodeType();
        #endregion

        #region COMMA
        private class CommaNodeType : FixedTokenNodeType
        {
            public CommaNodeType(): base ("COMMA", ",") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new CommaTokenElement(this);
            }
        }
        private class CommaTokenElement : FixedTokenElement
        {
            public CommaTokenElement(CommaNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType COMMA = new CommaNodeType();
        #endregion

        #region NAMESPACE_SEPARATOR
        private class NamespaceSeparatorNodeType : FixedTokenNodeType
        {
            public NamespaceSeparatorNodeType(): base ("NAMESPACE_SEPARATOR", ":") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new NamespaceSeparatorTokenElement(this);
            }
        }
        private class NamespaceSeparatorTokenElement : FixedTokenElement
        {
            public NamespaceSeparatorTokenElement(NamespaceSeparatorNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType NAMESPACE_SEPARATOR = new NamespaceSeparatorNodeType();
        #endregion

        #region L_BRACE
        private class LBraceNodeType : FixedTokenNodeType
        {
            public LBraceNodeType(): base ("L_BRACE", "{") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new LBraceTokenElement(this);
            }
        }
        private class LBraceTokenElement : FixedTokenElement
        {
            public LBraceTokenElement(LBraceNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType L_BRACE = new LBraceNodeType();
        #endregion

        #region R_BRACE
        private class RBraceNodeType : FixedTokenNodeType
        {
            public RBraceNodeType(): base ("R_BRACE", "}") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new RBraceTokenElement(this);
            }
        }
        private class RBraceTokenElement : FixedTokenElement
        {
            public RBraceTokenElement(RBraceNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType R_BRACE = new RBraceNodeType();
        #endregion

        #region L_PARENTHESES
        private class LParenthesesNodeType : FixedTokenNodeType
        {
            public LParenthesesNodeType(): base ("L_PARENTHESES", "(") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new LParenthesesTokenElement(this);
            }
        }
        private class LParenthesesTokenElement : FixedTokenElement
        {
            public LParenthesesTokenElement(LParenthesesNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType L_PARENTHESES = new LParenthesesNodeType();
        #endregion

        #region R_PARENTHESES
        private class RParenthesesNodeType : FixedTokenNodeType
        {
            public RParenthesesNodeType(): base ("R_PARENTHESES", ")") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new RParenthesesTokenElement(this);
            }
        }
        private class RParenthesesTokenElement : FixedTokenElement
        {
            public RParenthesesTokenElement(RParenthesesNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType R_PARENTHESES = new RParenthesesNodeType();
        #endregion

        #region L_BRACKET
        private class LBracketNodeType : FixedTokenNodeType
        {
            public LBracketNodeType(): base ("L_BRACKET", "[") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new LBracketTokenElement(this);
            }
        }
        private class LBracketTokenElement : FixedTokenElement
        {
            public LBracketTokenElement(LBracketNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType L_BRACKET = new LBracketNodeType();
        #endregion

        #region R_BRACKET
        private class RBracketNodeType : FixedTokenNodeType
        {
            public RBracketNodeType(): base ("R_BRACKET", "]") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new RBracketTokenElement(this);
            }
        }
        private class RBracketTokenElement : FixedTokenElement
        {
            public RBracketTokenElement(RBracketNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType R_BRACKET = new RBracketNodeType();
        #endregion

        #region NULL_KEYWORD
        private class NullKeywordNodeType : KeywordTokenNodeType
        {
            public NullKeywordNodeType(): base ("NULL_KEYWORD", "null") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new NullKeywordTokenElement(this);
            }
        }
        private class NullKeywordTokenElement : FixedTokenElement
        {
            public NullKeywordTokenElement(NullKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType NULL_KEYWORD = new NullKeywordNodeType();
        #endregion

        #region TRUE_KEYWORD
        private class TrueKeywordNodeType : KeywordTokenNodeType
        {
            public TrueKeywordNodeType(): base ("TRUE_KEYWORD", "true") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new TrueKeywordTokenElement(this);
            }
        }
        private class TrueKeywordTokenElement : FixedTokenElement
        {
            public TrueKeywordTokenElement(TrueKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType TRUE_KEYWORD = new TrueKeywordNodeType();
        #endregion

        #region FALSE_KEYWORD
        private class FalseKeywordNodeType : KeywordTokenNodeType
        {
            public FalseKeywordNodeType(): base ("FALSE_KEYWORD", "false") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new FalseKeywordTokenElement(this);
            }
        }
        private class FalseKeywordTokenElement : FixedTokenElement
        {
            public FalseKeywordTokenElement(FalseKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType FALSE_KEYWORD = new FalseKeywordNodeType();
        #endregion

        #region HAS_KEYWORD
        private class HasKeywordNodeType : KeywordTokenNodeType
        {
            public HasKeywordNodeType(): base ("HAS_KEYWORD", "@has") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new HasKeywordTokenElement(this);
            }
        }
        private class HasKeywordTokenElement : FixedTokenElement
        {
            public HasKeywordTokenElement(HasKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType HAS_KEYWORD = new HasKeywordNodeType();
        #endregion

        #region IS_KEYWORD
        private class IsKeywordNodeType : KeywordTokenNodeType
        {
            public IsKeywordNodeType(): base ("IS_KEYWORD", "@is") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new IsKeywordTokenElement(this);
            }
        }
        private class IsKeywordTokenElement : FixedTokenElement
        {
            public IsKeywordTokenElement(IsKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType IS_KEYWORD = new IsKeywordNodeType();
        #endregion

        #region FOR_ALL_KEYWORD
        private class ForAllKeywordNodeType : KeywordTokenNodeType
        {
            public ForAllKeywordNodeType(): base ("FOR_ALL_KEYWORD", "@forAll") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ForAllKeywordTokenElement(this);
            }
        }
        private class ForAllKeywordTokenElement : FixedTokenElement
        {
            public ForAllKeywordTokenElement(ForAllKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType FOR_ALL_KEYWORD = new ForAllKeywordNodeType();
        #endregion

        #region FOR_SOME_KEYWORD
        private class ForSomeKeywordNodeType : KeywordTokenNodeType
        {
            public ForSomeKeywordNodeType(): base ("FOR_SOME_KEYWORD", "@forSome") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ForSomeKeywordTokenElement(this);
            }
        }
        private class ForSomeKeywordTokenElement : FixedTokenElement
        {
            public ForSomeKeywordTokenElement(ForSomeKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType FOR_SOME_KEYWORD = new ForSomeKeywordNodeType();
        #endregion

        #region A_KEYWORD
        private class AKeywordNodeType : KeywordTokenNodeType
        {
            public AKeywordNodeType(): base ("A_KEYWORD", "a") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new AKeywordTokenElement(this);
            }
        }
        private class AKeywordTokenElement : FixedTokenElement
        {
            public AKeywordTokenElement(AKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType A_KEYWORD = new AKeywordNodeType();
        #endregion

        #region OF_KEYWORD
        private class OfKeywordNodeType : KeywordTokenNodeType
        {
            public OfKeywordNodeType(): base ("OF_KEYWORD", "@of") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new OfKeywordTokenElement(this);
            }
        }
        private class OfKeywordTokenElement : FixedTokenElement
        {
            public OfKeywordTokenElement(OfKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType OF_KEYWORD = new OfKeywordNodeType();
        #endregion

        #region PREFIX_KEYWORD
        private class PrefixKeywordNodeType : KeywordTokenNodeType
        {
            public PrefixKeywordNodeType(): base ("PREFIX_KEYWORD", "@prefix") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new PrefixKeywordTokenElement(this);
            }
        }
        private class PrefixKeywordTokenElement : FixedTokenElement
        {
            public PrefixKeywordTokenElement(PrefixKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType PREFIX_KEYWORD = new PrefixKeywordNodeType();
        #endregion

        #region STD_PREFIX_KEYWORD
        private class StdPrefixKeywordNodeType : KeywordTokenNodeType
        {
            public StdPrefixKeywordNodeType(): base ("STD_PREFIX_KEYWORD", "@std_prefix") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new StdPrefixKeywordTokenElement(this);
            }
        }
        private class StdPrefixKeywordTokenElement : FixedTokenElement
        {
            public StdPrefixKeywordTokenElement(StdPrefixKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType STD_PREFIX_KEYWORD = new StdPrefixKeywordNodeType();
        #endregion

        #region EXTENSION_KEYWORD
        private class ExtensionKeywordNodeType : KeywordTokenNodeType
        {
            public ExtensionKeywordNodeType(): base ("EXTENSION_KEYWORD", "@extension") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ExtensionKeywordTokenElement(this);
            }
        }
        private class ExtensionKeywordTokenElement : FixedTokenElement
        {
            public ExtensionKeywordTokenElement(ExtensionKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType EXTENSION_KEYWORD = new ExtensionKeywordNodeType();
        #endregion

        #region USING_KEYWORD
        private class UsingKeywordNodeType : KeywordTokenNodeType
        {
            public UsingKeywordNodeType(): base ("USING_KEYWORD", "@using") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new UsingKeywordTokenElement(this);
            }
        }
        private class UsingKeywordTokenElement : FixedTokenElement
        {
            public UsingKeywordTokenElement(UsingKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType USING_KEYWORD = new UsingKeywordNodeType();
        #endregion

        #region DEFAULT_AXIS_KEYWORD
        private class DefaultAxisKeywordNodeType : KeywordTokenNodeType
        {
            public DefaultAxisKeywordNodeType(): base ("DEFAULT_AXIS_KEYWORD", "@axis-default") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new DefaultAxisKeywordTokenElement(this);
            }
        }
        private class DefaultAxisKeywordTokenElement : FixedTokenElement
        {
            public DefaultAxisKeywordTokenElement(DefaultAxisKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType DEFAULT_AXIS_KEYWORD = new DefaultAxisKeywordNodeType();
        #endregion

        #region BIND
        private class BindNodeType : FixedTokenNodeType
        {
            public BindNodeType(): base ("BIND", "->") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new BindTokenElement(this);
            }
        }
        private class BindTokenElement : FixedTokenElement
        {
            public BindTokenElement(BindNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType BIND = new BindNodeType();
        #endregion

        #region IMPLIES
        private class ImpliesNodeType : FixedTokenNodeType
        {
            public ImpliesNodeType(): base ("IMPLIES", "=>") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ImpliesTokenElement(this);
            }
        }
        private class ImpliesTokenElement : FixedTokenElement
        {
            public ImpliesTokenElement(ImpliesNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType IMPLIES = new ImpliesNodeType();
        #endregion

        #region SAME_AS
        private class SameAsNodeType : FixedTokenNodeType
        {
            public SameAsNodeType(): base ("SAME_AS", "=") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new SameAsTokenElement(this);
            }
        }
        private class SameAsTokenElement : FixedTokenElement
        {
            public SameAsTokenElement(SameAsNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType SAME_AS = new SameAsNodeType();
        #endregion

        #region NAME_KEY
        private class NameKeyNodeType : FixedTokenNodeType
        {
            public NameKeyNodeType(): base ("NAME_KEY", ":-") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new NameKeyTokenElement(this);
            }
        }
        private class NameKeyTokenElement : FixedTokenElement
        {
            public NameKeyTokenElement(NameKeyNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType NAME_KEY = new NameKeyNodeType();
        #endregion

        #region NOT_EQUAL_TO
        private class NotEqualToNodeType : FixedTokenNodeType
        {
            public NotEqualToNodeType(): base ("NOT_EQUAL_TO", "!=") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new NotEqualToTokenElement(this);
            }
        }
        private class NotEqualToTokenElement : FixedTokenElement
        {
            public NotEqualToTokenElement(NotEqualToNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType NOT_EQUAL_TO = new NotEqualToNodeType();
        #endregion

        #region CONNECT
        private class ConnectNodeType : FixedTokenNodeType
        {
            public ConnectNodeType(): base ("CONNECT", "<->") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ConnectTokenElement(this);
            }
        }
        private class ConnectTokenElement : FixedTokenElement
        {
            public ConnectTokenElement(ConnectNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType CONNECT = new ConnectNodeType();
        #endregion

        #region DATA_SUFFIX
        private class DataSuffixNodeType : FixedTokenNodeType
        {
            public DataSuffixNodeType(): base ("DATA_SUFFIX", "^^") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new DataSuffixTokenElement(this);
            }
        }
        private class DataSuffixTokenElement : FixedTokenElement
        {
            public DataSuffixTokenElement(DataSuffixNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType DATA_SUFFIX = new DataSuffixNodeType();
        #endregion

        #region EXPRESSION_TAIL_OPERATOR
        private class ExpressionTailOperatorNodeType : FixedTokenNodeType
        {
            public ExpressionTailOperatorNodeType(): base ("EXPRESSION_TAIL_OPERATOR", "^") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ExpressionTailOperatorTokenElement(this);
            }
        }
        private class ExpressionTailOperatorTokenElement : FixedTokenElement
        {
            public ExpressionTailOperatorTokenElement(ExpressionTailOperatorNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType EXPRESSION_TAIL_OPERATOR = new ExpressionTailOperatorNodeType();
        #endregion

    }
}
 
